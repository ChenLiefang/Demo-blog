## 浏览器篇

* 一个页面从输入URL到页面显示加载完成，这个过程都发生了什么？
  1.浏览器根据请求的URL交给DNS域名解析，找到真实ip
  2.浏览器根据IP地址像服务器发起TCP连接，与浏览器建立TCP三次握手
    a.客户端像服务器发送一个建立连接的请求
    b.服务器收到请求后发送同意连接的信号
    c.客户端接到同意连接的信号以后，再次向服务器发送确认信号，然后客户端与服务器连接建立成功
  3.浏览器发送HTTP请求
    浏览器根据URL内容生成HTTP请求，请求中包含请求文件的位置，请求文件的方式等
  4.服务器处理请求并返回HTTP报文（HTTP的响应报文也是由三部分组成：状态码 响应报头 响应报文）
    a.服务器接到请求后，会根据HTTP请求中的内容来决定如何获取相应的HTML文件
    b.服务器将得到的HTML文件发送给浏览器
    c.浏览器还没有完全接收HTML文件时便开始渲染，显示网页
    d.在执行HTML代码中，根据需求浏览器会继续请求图片。css，javascript 等文件过程同请求HTML
  5.断开连接

* 浏览器的缓存
    1.sessionStorageuo
    优点：可以临时存储，关闭页面标签自动回收，不支持跨页面交互
    缺点：只能作为临时存储，不能存储持久化
    2.localStorage
    优点：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动删除
    缺点：存在大小限制，IE8以上的版本才支持；目前所有的浏览器中都会把localStorage值限定为string类型，常见的JSON对象都需要转换
    3.cookie
    优点：兼容性最好，几乎所有的浏览器都支持
    缺点：大小有限制，而且每次都会发请求，请求头里会带着cookie一起发过去

* HTTP和https的区别
    HTTP是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议
    https 需要申请证书，一般免费证书比较少，因而需要一定费用
    HTTP和HTTPS使用的是完全不同的连接方式，用的端口也是不一样的，前者是80，后者是443
    HTTP的连接很简单，无状态 https协议是加密传输。身份认证的网络协议，比HTTP协议更加安全

## HTML篇
* Doctype作用
    告知浏览器的解析器用什么文档标准解析这个文档
* 说说你对语义化的理解
  语义化标签主要有 title header nav h1-h6 ul ol address canvas section mark 
  语义化的优点：
  ·代码结构清晰 易于阅读 利于开发和维护
  ·提高用户体验，在样式加载失败时页面结构清晰
  ·方便其他设备根据语义渲染网页
  ·有利于搜索引擎优化
* 页面导入样式时，使用link 和@import 有什么区别
  ·属性差别。link属于xhtml标签 @import 是css提供的语法规则
  ·加载顺序的差别；当一个页面被加载时link引用的css会同时被加载，import引用的页面需要全部被下载才会加载
  ·使用dom控制样式的差别 当使用javascript去控制dom改变样式额时候，只能使用link标签 

* HTML5 有哪些新特性？
    1.语义化标签
    2.增强型表单
    3.webSocket 
    4.Svg绘图
    5.web storage 
    6.新增视频和音频标签
* img 中的Alt与title属性
    alt是图片加载失败时，显示在网页上的替代文字
    title是鼠标放在图片上时显示的文字，title是对图片的描述与进一步说明
    alt是img 的必要属性但是title不是
    对于网站的SEO 来说，搜索引擎对图片意思的判断主要考alt属性

## css篇

* BFC规范的理解
    BFC全称：块级格式化上下文，简单来说就是一种属性，这种属性会影响元素与元素之间的位置。间距 
    形成BFC的条件
     ·float：给元素添加浮动（属性值为left right 但none除外）
     ·position：给元素添加定位（属性为absolute fixed）
     ·display：给元素添加display属性（属性值为inline-block  table-cell table-caption）
     ·overflow：给元素添加overflow属性（属性值为 hidden auto scroll 但visible除外）
    BFC形成后出现的常见问题
     ·margin重叠问题
     ·浮动相关问题
* 清除浮动有哪些方式？
    ·利用clear：both样式（新增一个空的div。然后给这个空的div添加clear：both属性即可）
    ·利用overflow：hidden清除浮动（子元素设置浮动后；直接给父元素添加overflow：hidden即可）
    ·利用伪元素（推荐）：：after（给末尾添加一个看不见的块元素来清除浮动）

* 行内元素有哪些？块级元素有哪些？css的盒模型？
    块级元素： div p h1-h4 grom ul
    行内元素： a br span input select 
    css盒模型： 内容，border margin padding 
* css选择符都有哪些、哪些属性可以继承、优先算法如何计算？
    css选择符
      1.id选择器（#）
      2.类选择器（.）
      3.标签选择器（div h1 p ）
      4.相邻标签选择器（div +　ｐ）
      5.子选择器(ul > li )
      6.后代选择器（li a）
      7.通配符选择器（*）
      8.属性选择器（a[rel='external']）
      9.伪类选择器（a:hover li:nth-child）
    可继承的样式
      1.font-size
      2.font-family
      3.color
      4.text-indent
    不可继承的样式
      border padding margin width height
    优先级算法
      1.优先级就近原则，样式定义最近者为准
      2.优先级更高选择谁 （important，ID选择器，类选择器，属性选择器， 标签选择器）
      3.important 比 内联优先级高，但内联比 id 要高
* css3新增伪类举例
    1、否定伪类选择器
      div：not(div2) 除div2之外的全部div
    2、同一父元素下 最后（第一）某一个元素
      li:last-child 
      li:first-child
      li:nth-child(3)
    3、父元素下仅有一个元素
      span:only-child  只有一个span元素
    4、匹配空元素（没有子元素的元素）
      div：empty 
    5、UI元素状态伪类
      :enable选择可用表单元素
      :disable选择禁用表单元素
      :checked被选中的表单元素
      :root选择文档的根元素
      :target 活动的目标元素
      :after
      :before
      p:nth-child(n)
      p:nth-last-child(n)
      p:nth-of-type(n)
      p:nth-last-of-type(n)
      P:last-of-type
      p:last-child
      p:first-of-type
      P:first-child
* 如何居中div？
  1.利用flex布局 父元素的display为flex，并且水平方向和垂直方向都居中，子元素的高度可以设定也可以不设定
  2.绝对定位+上下左右都为0 margin为auto
  3.绝对定位+transform +left50% +top50%
  4.行内元素文字水平居中line-hight 设置为元素的高度
  5.横向利用margin auto，垂直还是利用定位和平移

* 为什么要初始化css
  浏览器差异，不同的浏览器对默认值是不同的 提高编码质量 如果没有初始化重复的css样式会比较多

* position float  display各有哪些取值，他们之间会如何相互影响？
    display ： none block  inline inline-block(行快内元素)
    position： inherit static relative absolute  fixed
    上面三个属性都属于CSS定位属性。CSS三种基本的定位机制：普通流、浮动、绝对定位。


# js篇
* 面向对象  
    面向对象的三个基本特征是继承 封装 多态
* 什么是闭包，闭包的特性是什么、
    闭包其实只是一个绑定了执行环境的函数
    闭包的特性：
    1.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的
    2.持久性：一般的函数调用完成以后系统会自动注销函数，但是对于闭包来说，在外部函数被调用后，闭包依旧存在
* DOM操作（添加、移除、移动、复制、创建、查找节点）

* 介绍一下new操作符，new操作符具体做了什么
  1.创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型
  2.属性和方法被加到this引用的对象中
  3.新创建的对象由this所引用，并且最后隐式的返回this

* js的数据类型 
  基本数据类型：Number String Boolean Null Undefined Symbol 
  引用数据类型： Object

* null 和undefined区别
  undefined不是一个有效的JSON 但是null是
  null和undefined的值相等但是类型不等 undefined 的类型是undefined null的类型是object
  主要区别在于转换为原始类型的方式 在null执行算术转换的值为0  但是undefined不是

* call() apply()的区别
  基本区别在于传参不同
  call(thisArg,arg1,arg2,arg3...) 把参数按顺序传递进去 明确参数数量时使用
  apply(thisArg,[arg1,arg2,arg3...]) 把参数放在数组里面 参数数量不明确时使用

* 深拷贝和浅拷贝
  首先深复制和浅复制只针对像 Object, Array 这样的复杂对象的。
  浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；
  深拷贝：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。

* ajax 异步请求数据的web开发技术

* 数组去重
  1.set方法
    function unique(arr){
      var set = new Set(arr);
      return Array.from(set);
    }
  2.双重遍历：
  ```
    function unique(arr) {
      var ret = [];
      var len = arr.length;
      for(var i=0; i<len; i++){
          for(var j=i+1; j<len; j++){
              if(arr[i] === arr[j]){
                  j = ++i;
              }
          }
          ret.push(arr[i]);
      }
      return ret;
    }
    ```
  3.Array.prototype.includes()
  ```
    function unique(arr) {
      var ret = [];
      arr.forEach(function(item){
          if(!ret.includes(item)){
              ret.push(item);
          }
      });
      return ret;
    }
  ```
  4.Array.prototype.indexOf() 
  ```
    function unique(arr) {
      return arr.filter(function(item, index){
          // indexOf返回第一个索引值，
          // 如果当前索引不是第一个索引，说明是重复值
          return arr.indexOf(item) === index;
      });
   }
  ```
  5.Map是一种新的数据类型，可以把它想象成key类型没有限制的对象。此外，它的存取使用单独的get()、set()接口。
  ```
    function unique(arr) {
      var ret = [];
      var len = arr.length;
      var tmp = new Map();
      for(var i=0; i<len; i++){
          if(!tmp.get(arr[i])){
              tmp.set(arr[i], 1);
              ret.push(arr[i]);
          }
      }
      return ret;
  }
  ```
* 什么是UA？
  User-Agent中文名为用户代理 是Http协议中的一部分
* 什么是事件委托
  事件委托是利用事件的冒泡原理来实现的
  何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件
  优点：
  减少事件注册，节省内存。比如，
    在table上代理所有td的click事件。
    在ul上代理所有li的click事件。
  简化了dom节点更新时，相应事件的更新。比如
    不用在新添加的li上绑定click事件。
    当删除某个li时，不用移解绑上面的click事件。
* var let const有什么区别
  1.var定义的变量可以跨快作用域访问，不可以跨函数作用域使用
  2.let定义的变量 只能在块级作用域访问。不能跨快访问，也不能跨函数访问，不允许在相同的作用域里面，重复声明同一个变量
  3.const定义的常量 初始化时必须赋值 只能在块级作用域里面使用 不能修改 
  
* js是什么语言
    js是运行在浏览器的脚本语言，这种语言的主要功能是制作出动态的页面效果
    js语言是弱语言类型，因此我们在项目开发中随意改变某个变量的数据类型以后，会导致引用一、
    这个变量的方法报错
* 原型 
    javascript中的对象都有一个特殊的prototype内置属性，其实就是对其他对象的引用
    几乎所有的对象在创建时prototype属性都会被赋予一个非空的值
* 原型链 
* 执行上下文 

# 前端安全问题
  xss（跨站脚本攻击）
  CSRF 


# 跨域  
* 什么是跨域？
  当协议子域名 主域名 端口号中任意一个不同时，都算作不同域，不同域之间相互请求资源，就算跨域
* 什么是同源策略
  同源策略是一种约定，他是浏览器最核心也是最基本的安全功能，缺少同源策略，浏览器会受到xss CSRF 的攻击 同源是指 协议+ 端口 + 域名  即便两个不同的域名指向同一个ip地址 也非同源
  一个域名地址的组成 http://(协议)  www(子域名) . abc.com(主域名) : 8080(端口号) / script.js(请求资源地址)
  同源策略限制内容有：
  Cookie LocalStorage indexedDB等存储性内容；DOM节点 ； AJAX请求发送后，结果被浏览器拦截了
  但是有三个标签允许跨域加载资源  <img src=XXX>   <link href=XXX> <script src=XXX>
* 解决跨域的方法有哪些？
  1.jsonp 
   jsonp原理 ：利用 <script>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。
   jsonp和Ajax对比：两者相同，都是客户端向服务端发送请求，从服务端获取数据的方式，但是ajax属于同源策略，jsop 属于非同源策略（跨域请求） 
   jsonp 优缺点：兼容性比较好，可用于解决主流浏览器的跨域数据访问 缺点是仅仅支持get方法具有局限性 不安全可能遭受xss攻击
  2.cors、
   cors需要浏览器和后端同时支持
  3.websocket
   WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
   原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
  4.postMessage 
   可以跨域操作的window属性之一


## ES6新特性
一、变量





